# Scalability 与一致性说明

## 系统扩展性 (Scalability)

### 1. 水平扩展能力

#### 后端服务扩展
- **无状态设计**: 所有后端服务实例都是无状态的
- **负载均衡**: 可以通过 Load Balancer 分发请求
- **会话管理**: 使用 JWT Token，无需服务器端会话存储

```
┌─────────────┐
│ Load        │
│ Balancer    │
└──────┬──────┘
       │
   ┌───┴───┬─────────┬─────────┐
   │       │         │         │
┌──▼──┐ ┌──▼──┐  ┌──▼──┐  ┌──▼──┐
│ BE1 │ │ BE2 │  │ BE3 │  │ BEN │
└─────┘ └─────┘  └─────┘  └─────┘
```

#### Redis 扩展
- **Redis Cluster**: 支持分片和主从复制
- **数据分片**: 可以按商品 ID 分片
- **读写分离**: 主节点写入，从节点读取

#### 数据库扩展
- **主从复制**: PostgreSQL 支持主从复制
- **读写分离**: 写操作到主节点，读操作到从节点
- **连接池**: 使用连接池管理数据库连接

### 2. 垂直扩展能力

#### 资源监控
- **CPU**: 监控 CPU 使用率，设置阈值告警
- **内存**: 监控内存使用，防止 OOM
- **连接数**: 监控数据库和 Redis 连接数

#### 性能调优
- **连接池大小**: 根据并发量调整
- **缓存策略**: 优化 Redis 缓存命中率
- **数据库索引**: 优化查询性能

### 3. 扩展性指标

| 指标 | 当前能力 | 扩展后能力 |
|------|---------|-----------|
| 并发用户 | 1000+ | 10000+ |
| RPS | 1000+ | 10000+ |
| WebSocket 连接 | 1000+ | 10000+ |
| 响应时间 (p95) | < 500ms | < 500ms |

## 一致性保证 (Consistency)

### 1. 强一致性场景

#### 排行榜更新
- **实现**: Lua Script 原子操作
- **保证**: 单线程执行，保证原子性
- **场景**: 出价时更新排行榜

```lua
-- Lua Script 保证原子性
local rank_key = KEYS[1]
local user_id = ARGV[1]
local score = ARGV[2]

-- 原子性更新
redis.call("ZADD", rank_key, score, user_id)
```

#### 库存检查
- **实现**: Lua Script 中检查活动时间
- **保证**: 防止活动结束后继续出价
- **场景**: 出价时检查活动状态

### 2. 最终一致性场景

#### 数据库写入
- **实现**: 异步 Goroutine 写入
- **保证**: 最终会写入数据库
- **场景**: 出价记录异步持久化

```go
// 异步写入数据库
go func() {
    s.db.Create(&database.BidLog{
        UserID: userID,
        ProductID: productID,
        Price: price,
        Score: score,
        CreatedAt: time.Now(),
    })
}()
```

#### WebSocket 推送
- **实现**: 异步广播消息
- **保证**: 最终所有客户端会收到更新
- **场景**: 排行榜更新推送

### 3. 一致性模型

#### CAP 定理分析
- **Consistency (一致性)**: 
  - 排行榜：强一致性（Lua Script）
  - 数据库：最终一致性（异步写入）
  
- **Availability (可用性)**: 
  - 高可用（多实例部署）
  - Redis 主从复制
  - 数据库主从复制
  
- **Partition Tolerance (分区容错)**: 
  - Redis Cluster 支持分区
  - 数据库主从复制支持分区

**选择**: 优先保证 **Availability** 和 **Partition Tolerance**，在关键场景（排行榜）保证 **Consistency**

### 4. 数据一致性验证

#### 验证方法
1. **出价记录数 <= K**: 通过 Lua Script 保证
2. **排行榜用户数 <= K**: Redis Sorted Set 自动维护
3. **数据库与 Redis 一致性**: 定期验证脚本

#### 验证脚本
```bash
# 运行数据验证
python loadtest/verify_data.py
```

## 性能优化策略

### 1. 缓存策略

#### Redis 缓存
- **商品配置**: 缓存商品参数（K, alpha, beta, gamma）
- **排行榜**: 实时排行榜（Sorted Set）
- **最高价**: 缓存当前最高价

#### 缓存更新
- **写穿透**: 更新时同时更新缓存
- **失效策略**: 活动结束后清理缓存

### 2. 数据库优化

#### 索引优化
```sql
-- 用户表索引
CREATE INDEX idx_users_username ON users(username);

-- 出价记录索引
CREATE INDEX idx_bid_logs_product ON bid_logs(product_id);
CREATE INDEX idx_bid_logs_user ON bid_logs(user_id);
```

#### 查询优化
- **分页查询**: 避免全表扫描
- **连接池**: 复用数据库连接
- **批量操作**: 批量写入出价记录

### 3. 网络优化

#### HTTP 优化
- **压缩**: Gzip 压缩响应
- **Keep-Alive**: 复用 HTTP 连接
- **CDN**: 静态资源使用 CDN

#### WebSocket 优化
- **心跳**: 定期发送 Ping/Pong
- **重连**: 指数退避重连策略
- **消息压缩**: 大消息压缩传输

## 监控与告警

### 1. 关键指标

#### 性能指标
- **响应时间**: p50, p95, p99
- **吞吐量**: RPS (Requests Per Second)
- **错误率**: 4xx, 5xx 错误比例

#### 系统指标
- **CPU 使用率**: < 80%
- **内存使用率**: < 80%
- **连接数**: 数据库和 Redis 连接数

#### 业务指标
- **出价成功率**: > 95%
- **排行榜更新延迟**: < 100ms
- **WebSocket 连接数**: 实时监控

### 2. 告警规则

#### 告警阈值
- **响应时间 p95 > 1s**: 告警
- **错误率 > 5%**: 告警
- **CPU 使用率 > 90%**: 告警
- **内存使用率 > 90%**: 告警

## 故障恢复

### 1. 故障场景

#### Redis 故障
- **影响**: 排行榜无法更新
- **恢复**: 从数据库重建排行榜
- **预防**: Redis 主从复制

#### 数据库故障
- **影响**: 无法持久化数据
- **恢复**: 从 Redis 恢复数据
- **预防**: 数据库主从复制

#### 服务故障
- **影响**: 服务不可用
- **恢复**: 自动重启或切换实例
- **预防**: 多实例部署，健康检查

### 2. 数据恢复

#### 从 Redis 恢复
```go
// 从 Redis 恢复排行榜到数据库
func RecoverRankingsFromRedis(productID string) {
    // 从 Redis 读取排行榜
    // 写入数据库
}
```

#### 从数据库恢复
```go
// 从数据库重建 Redis 排行榜
func RebuildRankingsFromDB(productID string) {
    // 从数据库读取出价记录
    // 重建 Redis 排行榜
}
```

## 总结

### 扩展性
- ✅ **水平扩展**: 支持多实例部署
- ✅ **垂直扩展**: 支持资源扩容
- ✅ **缓存优化**: Redis 缓存热点数据
- ✅ **数据库优化**: 索引和查询优化

### 一致性
- ✅ **强一致性**: 排行榜更新（Lua Script）
- ✅ **最终一致性**: 数据库写入（异步）
- ✅ **数据验证**: 定期验证脚本
- ✅ **故障恢复**: 数据恢复机制

### 性能
- ✅ **响应时间**: p95 < 500ms
- ✅ **吞吐量**: 1000+ RPS
- ✅ **并发支持**: 1000+ 用户
- ✅ **实时性**: WebSocket < 100ms 延迟

